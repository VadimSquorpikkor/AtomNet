<!DOCTYPE html>

<html lang="ru">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=0.8">
    <meta charset="UTF-8">
    <title>Администрирование</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <script type="text/javascript" src="../include.js"></script>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <script>window.addEventListener('scroll', trackScroll)</script>
</head>

<body>

<a class="to_page_top" title="Наверх">&uparrow;</a>

<div class="menu_and_main_div">

    <div class="header_div_2">
        <input title="" name="menu_btn" type="button" value="Меню" onclick="show_menu()" class="menu_button"
               id="menu_button">

        <a href="../menu/index.html">Главная</a>
        <a href="../other/adjustment_db.html">AdjustmentDB</a>
        <a href="../other/adjustment_db_service.html">Описание сервиса</a>
        <a href="">Администрирование</a>

        <div class="spoiler_menu" id="menu" style="display: none"></div>
    </div>

    <div class="left_side_menu">
        <div id="menu_left" class="spoiler_menu"></div>
    </div>

    <script>
        includeMenu("menu_left", REG_MENU, OPEN);
        includeMenu("menu", REG_MENU, CLOSE);
    </script>

    <div class="main_div">

        <h1>Администрирование</h1>

        <h3><span class="attention">Описание не окончено, в работе</span></h3>

        <img src="../imgs/under_construction.jpg" alt="изображение не найдено">

        <h3>AdjustmentDB</h3>

        <p>БД расположена на Firebase Firestore, аккаунт uchastok.rir@gmail.com, проект <a
                href="https://console.firebase.google.com/u/1/project/adjustmentdb/overview">AdjustmentDB</a></p>

        <p>
            Надо понимать: только две таблицы доступны для записи пользователям AdjustmentDB, во все остальные НЕЛЬЗЯ ни
            изменить ни добавить данные ни в одном из подключенных к БД приложений, только я, как администратор, могу
            добавить/изменить таблицы по необходимости (добавить новый тип устройства, добавить нового пользователя и
            т.д.). Т.е. пользователь добавляет данные только в таблицу units (юниты) и в events (события), другие
            таблицы только для чтения, в них содержаться неизменяемые данные для работы приложений. Пользователи
            приложений AdjustmentWeb, AtomtexRepairs, RepairsTracker вообще не имеют доступа к записи каких либо данных,
            они используют БД только для чтения
        </p>

        <p><span class="underline_italic">id.</span>
            В каждой коллекции (то же таблице) идентификатор — это имя документа, он же — primaryKey.

        </p>

        <p>
            <span class="attention">Deprecated</span><br>
            Не используется для поиска по БД, документ из БД берется по его названию. Нужен для получения названия
            документа, когда приложение уже работает с объектом класса, полученного из документа. Можно было бы
            использовать и для поиска по БД (where id == entity.getId), но я не использую. При том, что имя документа и
            его id совпадают, можно в любой момент поменять логику, не меняя данные в БД. Id это не имя, так как
            пользователь может поменять email и тогда будет два пользователя: со старым и новым email. Если же есть id
            (просто номер), то поиск по такому id вернет все записи с этими двумя email вместе
        </p>

        <p><span class="attention">Deprecated</span><span class="underline_italic">name_id.</span>
            Есть в каждой таблице (кроме units, у которых имя — это свойство связанного с юнитом девайса, и кроме names
            эта таблица и является собственно таблицей имен). Обозначает идентификатор, по которому в таблице имен
            (names) берется собственно имя, т.е. имена не хранятся в самих документах. Само имя может быть разным
            (точнее на разных языках), но сам идентификатор один, в зависимости от выбранного языка объекту по
            идентификатору присваивается имя. Процесс такой:
        <ul>
            <li>у объекта берется name_id и по нему в таблице имен выбирается документ с таким id (с именами процесс
                немного сложнее, будет подробно описан далее)
            </li>
            <li>из документа выбирается имя на нужном языке</li>
            <li>это имя уже получает объект</li>
        </ul>
        </p>


        <h4>Таблицы (коллекции)</h4>

        <p><span class="underline_italic">device_set</span>
            — комплекты устройств. Многие устройства относятся к какому-то комплекту (БДКГ-01 к 1117М) или к нескольким,
            или не относятся ни к какому. Добавлено для необходимости сгруппировать устройства по комплектам, чтобы
            как-то уменьшить размер списка в момент выбора названия устройства в диалоге, слишком много устройств
        </p>

        <p><span class="underline_italic">devices.</span>
            Список всех возможных устройств. Нужно подчеркнуть — это не реальные устройства, а их описание, "чертежи".
        </p>

        <p><span class="underline_italic">employees.</span>
            — список сотрудников. Это и ответственные за ремонт, и пользователи устройств с установленным AdjustmentDB.
        <ul>
            <li>Пользователи приложения. Для работы приложения на устройстве необходимо выбрать пользователя (google
                аккаунт), который должен быть зарегистрирован в БД. У такого пользователя в БД назначены email, id
                локации и имя. При запуске приложение проверяет выбранного пользователя и назначает приложению
                привязанную к этому пользователю локацию. Если такого пользователя в БД не будет найдено, дальнейшая
                работа приложения будет не возможна. Такого пользователя может и не существовать реально, это просто
                зарегистрированный в БД аккаунт на смартфоне
            </li>
            <li>Ответственный за ремонт. Это — сотрудник уРиР, назначенный ответственным за ремонт (или серию)
                устройства. У такого employee поля email и location не заданы (равны "")
            </li>
        </ul>

        </p>

        <!--Такого пользователя может и не существовать реально-->

        <p><span class="underline_italic">events.</span>
            Событие (Event) — единица истории устройства. Вся история есть список событий, в каждом из которых
            хранится дата/время, описание (если нужно), локация, статус и юнит
        </p>

        <p><span class="underline_italic">locations.</span>
            Локация — это название местонахождения устройства: участок регулировки, сборки и т.д. У каждого участка свой
            набор возможных статусов: у регулировки есть диагностика, настройка и другие, при этом пользователь не может
            назначить для устройства статус, которого нет у текущей локации. При этом для каждого из типов (серия или
            ремонт) может быть свой набор статусов, а может и не быть: так, например, для участка монтажа и для серии, и
            для ремонта один и тот же доступный статус — монтаж. У участка ремонта же вообще нет типа "серия" (он вообще
            не занимается серийными приборами)
        </p>

        <p><span class="attention">Deprecated</span><span class="underline_italic">names.</span>

        </p>

        <p><span class="underline_italic">states.</span>
            Статус — это как называется то, что могут делать с устройством: Диагностика, Сборка, Монтаж и т.д.
            Могут быть двух типов: Серия и Ремонт. У каждой локации есть свой набор статусов
            <!--Также для каждого статуса есть своя локация--> .
        </p>

        <p><span class="underline_italic">units.</span>
            — реальное устройств, пришедшие в текущий ремонт (или серийное). Если то же самое устройство придет в снова
            в ремонт, это уже будет другой юнит. Не путать с devices
        </p>


        <p>

        </p>

        <h4>Принцип хранения/загрузки данных. Кэширование</h4>

        <p>

        </p>

        <!--Процесс такой: если администратор добавляет в БД какие-то новые данные (новый тип устройства, например)-->
        <!--в приложении хранится номер версии данных-->
        <p>
            Для уменьшения количества запросов в БД применяется кэширование — сохранение полученных данных из БД и
            использование их при необходимости без повторного обращения к БД. В БД хранится номер её версии, приложение
            при первом подключении к БД загружает данные и сохраняет их. Также приложение сохраняет версию БД. При
            последующих подключениях приложение сверяет свой номер версии с номером версии, хранящимся в БД. Если версия
            совпадает, приложение загружает данные из своей памяти, иначе подключается к БД и загружает их из БД (при
            этом обновляя номер версии в устройстве). Сейчас сохраняются следующие таблицы: devices, locations,
            device_set, states. Для каждой сущности сохраняются не только данные хранящиеся в таблице, но и связанные с
            этой таблицей имена (которые берутся из таблицы names). <!--Сама таблица names не кэшируется и не будет
            кэшироваться в будущем, так как данные из этой таблицы для devices, locations и device_set уже сохранены при
            сохранении в кэш этих коллекций.-->
        </p>
        <p>
            Такой вариант получения данных (кэширование плюс версия БД) решает проблему, когда нужно ограничить чтение
            БД при этом обеспечить актуальность данных в БД (вариант захардкодить данные плох тем, что при обновлении
            данных в БД нужно будет всем пользователям НЕМЕДЛЕННО обновить версию приложения, читай: собрать у всех
            пользователей смартфоны и самому обновить версию)
        </p>
        <p>
            Другими словами: при изменении данных в БД, данные в приложении обновляются: а) удаленно; б) автоматически,
            без участия пользователя; в) без необходимости обновлять приложение
        </p>


        <!--<figure>
            <img src="../imgs/bdkg/1.jpg" width="700">
            <figcaption>Рисунок 1</figcaption>
        </figure>-->

        <h4>Картинки устройств</h4>

        <p>
            Картинки для устройств хранятся (по крайней мере пока — потом посмотрим) на хостинге от AdjustmentWeb, в
            самой базе хранятся ссылки на эти картинки. Чтобы изменить/добавить картинку, нужно в проекте AdjustmentWeb
            добавить эти картинки в папку /pics и задеплоить изменения; в БД добавить ссылку на изображение (получится
            что-то типа https://adjustmentdb.web.app/pics/2503.png)
        </p>

        <h4>Добавление/изменение данных в БД</h4>

        <p>
            После того, как были добавлены/изменены данные в БД, нужно дать знать приложениям, что данные изменились,
            чтобы они обновили те данные, которые хранят в памяти смартфона (locations, devices, device_sets, states).
            Для этого нужно в БД увеличить номер версии БД: зайти в <i>Firebase Firestore</i> &rarr; коллекция <i>_settings</i>
            &rarr; <i>value</i>. Приложение при подключении к БД проверит номер версии БД, сравнит с номером версии на
            устройстве, после этого скачает данные из БД (обновит данные в приложении). Т.е. данные будут обновлены без
            обновления ПО.

            <!--Таким образом, при добавлении/изменении данных для devices в БД нужно увеличить номер её версии, так
            устройства с установленным ADB при подключении будут знать, что необходимо обновить данные. Т.е. данные
            будут обновлены без обновления ПО-->
        </p>

        <img src="../imgs/adjustment_admin/1.jpg" width="900" alt="изображение не найдено">

        <h3>AdjustmentWeb</h3>

        <h4>Deploy</h4>

        <p>
        <ol>
            <li>Открыть консоль CLI</li>
            <li>cd D:\GitHub\AtomNet</li>
            <li>firebase deploy</li>
        </ol>

        <img src="../imgs/adjustment_admin/2.jpg" width="800" alt="изображение не найдено">
        </p>
        <p>
            Некоторые файлы (.js и .css) могут добавиться только через пару минут, надо просто подождать (не обращать
            внимания, если что-то не работает или неправильно отображается, проверить позже)
        </p>
        <p>
            Если: <i>Error: Failed to get Firebase project uchastokrir2. Please make sure the project exists and your
            account has permission to access it.</i>
            Это значит, что консоль подключена к другому аккаунту/не подключена ни к какому аккаунту.
            Нужно выйти и зайти под аккаунтом uchastokrir2.
            Выйти: firebase logout.
            Войти: firebase login — перекинет на страничку, там выбрать аккаунт, нажать "allow", в консоле появится.
            "Success! Logged in as uchastok.rir@gmail.com".
            После этого деплоить как обычно.
        </p>
        <p>
            Если: <i>Error: HTTP Error: 429, You have exceeded the Hosting storage quota for your Firebase project, so
            you cannot deploy to your site right now. Visit the Firebase console to either manage your Hosting storage
            or upgrade to the Blaze plan.</i>
            Это значит, что закончилось место на хостинге.
            Заходим в Firebase->Hosting->Dashboard и в списке истории удаляем старые коммиты (хоть пару штук). Это
            предыдущие деплои, они не нужны, но firebase их хранит
        </p>

        <img src="../imgs/adjustment_admin/3.jpg" width="900" alt="изображение не найдено">

    </div>
</div>
</body>
</html>
